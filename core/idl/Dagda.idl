/**
 * @file Dagda.idl
 *
 * @brief  Dagda component IDL 
 *
 * @author  Gael Le Mahec (lemahec@clermont.in2p3.fr)
 *
 * @section Licence
 *   |LICENSE|
 */

#ifndef _DAGDA_IDL_
#define _DAGDA_IDL_

#include "common_types.idl"

/* - "lcl" prefix means "local".
   - "lvl" prefix means "from this level".
   - "pfm" prefix means "in the platform".
   - "dtm" prefix means "on this data manager".

   The "dtm*" methods are necessary if we plan to use the hierarchy to
   access a node. Otherwise, node->lcl* is sufficient. By overriding these
   methods, we can choose a routing strategy taking into account the network
   limitations like firewalls, network interface etc.

   To make different protocols wrappers, we can use methods override. Each node
   should execute its own DAGDA implementation taking into account its
   capabilities.
*/

/**
 * @brief The Dagda interface
 * @section DagdaIDL
 */
interface Dagda {
  /**
   * @brief Exception when a data is not found
   */
  exception DataNotFound {
    string dataID;
  };
  /**
   * @brief Exception when the path name is invalid
   */
  exception InvalidPathName {
    string dataID;
    string path;
  };
  /**
   * @brief Exception when there is an error reading 
   */
  exception ReadError {
    long error;
  };
  /**
   * @brief Exception when there is an error writting
   */
  exception WriteError {
    long error;
  };
  /**
   * @brief Exception when no space left on device
   */
  exception NotEnoughSpace {
    long available;
  };
  /**
   * @brief Exception when a file is unreachable
   */
  exception UnreachableFile {
    string path;
  };
  /**
   * @brief Exception when the access permission is denied
   */
  exception PermissionDenied {
	long error;
  };
  /**
   * @brief Exception when the data is unavailable
   */
  exception UnavailableData {
    string dataID;
  };
  /* Is the data using dataID is present. */
  /**
   * @brief If the data is locally present
   * @param dataId: The ID of the data
   * @return True if present
   */
  boolean lclIsDataPresent(in string dataID);
  /**
   * @brief If the data is present from this level
   * @param dataId: The ID of the data
   * @return True if present
   */
  boolean lvlIsDataPresent(in string dataID);
  /**
   * @brief If the data is present in the platform
   * @param dataId: The ID of the data
   * @return True if present
   */
  boolean pfmIsDataPresent(in string dataID);

  /* Add a data. */
  /**
   * @brief Add a local data
   * @param srcDagda: The source of the data
   * @param data: The data to add
   */
  void lclAddData(in string srcDagda, in corba_data_t data)
    raises(InvalidPathName, ReadError, WriteError, NotEnoughSpace);
  /**
   * @brief Add a data from this level
   * @param srcDagda: The source of the data
   * @param data: The data to add
   */
  void lvlAddData(in string srcDagda, in corba_data_t data)
    raises(InvalidPathName, ReadError, WriteError, NotEnoughSpace);
  /**
   * @brief Add a data from the platform
   * @param srcDagda: The source of the data
   * @param data: The data to add
   */
  void pfmAddData(in string srcDagda, in corba_data_t data)
    raises(InvalidPathName, ReadError, WriteError, NotEnoughSpace);
  /**
   * @brief Register a file. (without copying it. Used to declare a file present at
   * launching time or shared by SeDs.) 
   * @param data: The data (file) to add
   */
  void registerFile(in corba_data_t data)
    raises(InvalidPathName, UnreachableFile);

  /**
   * @brief Add a container-element relationship 
   */
  void lclAddContainerElt(in string containerID,
                          in string dataID,
                          in long index,
                          in long flag)
    raises(DataNotFound);

  /* Get the size ie nb of elements of a container */
  long lclGetContainerSize(in string containerID);

  /* Get all IDs of the elements of a container */
  void lclGetContainerElts(in string containerID,
                           inout SeqString dataIDSeq,
                           inout SeqLong flagSeq,
                           in boolean ordered);

  /* Remove a data. */
  void lclRemData(in string dataID);
  void lvlRemData(in string dataID);
  void pfmRemData(in string dataID);

  /* Update a data. */
  void lclUpdateData(in string srcDagda, in corba_data_t data);
  void lvlUpdateData(in string srcDagda, in corba_data_t data);
  void pfmUpdateData(in string srcDagda, in corba_data_t data);

  /* Get the data description list. */
  SeqCorbaDataDesc_t lclGetDataDescList();
  SeqCorbaDataDesc_t lvlGetDataDescList();
  SeqCorbaDataDesc_t pfmGetDataDescList();

  /* Get The description of a data. */
  corba_data_desc_t lclGetDataDesc(in string dataID)
    raises(DataNotFound);
  corba_data_desc_t lvlGetDataDesc(in string dataID)
    raises(DataNotFound);
  corba_data_desc_t pfmGetDataDesc(in string dataID)
    raises(DataNotFound);

  /* Replicate the data considering the conditions. */
  oneway void lclReplicate(in string dataID, in long ruleTarget,
    in string pattern, in boolean replace);
  oneway void lvlReplicate(in string dataID, in long ruleTarget,
    in string pattern, in boolean replace);
  oneway void pfmReplicate(in string dataID, in long ruleTarget,
    in string pattern, in boolean replace);

  /* Write a file on the node storage ressource. If "replace" is true,
     the file is opened at the beginning, otherwise the data are added at
     the end of the file. Returns the path where the file was stored. */
  string writeFile(in SeqChar data, in string basename, in boolean replace)
    raises(InvalidPathName, WriteError, NotEnoughSpace);
  /* Send a file to a node. */
  string sendFile(in corba_data_t data, in string destDagda)
    raises(InvalidPathName, ReadError, WriteError);
  /* Record a data into memory. If "replace" is true,
     the data is erased or created and replaced by the new one.
     Returns the id of the data. */
/*  string recordData(in SeqChar data, in corba_data_desc_t dataDesc,
		    in boolean replace)
    raises(NotEnoughSpace);*/
  string recordData(in SeqChar data, in corba_data_desc_t dataDesc,
		    in boolean replace, in long offset)
    raises(NotEnoughSpace);
  /* Send a data to a node. */
  string sendData(in string ID, in string destDagda)
    raises(DataNotFound);
  /* Send a container to a node */
  string sendContainer(in string ID, in string destDagda, in boolean sendElements)
    raises(DataNotFound);


  typedef sequence<string> SeqDagda_t;
  enum dataStatus { ready, downloading, notOwner };
  /* Get the managers of a data. */
  SeqString lvlGetDataManagers(in string dataID);
  SeqString pfmGetDataManagers(in string dataID);

  /* Ask to this node to become its child. */
  void subscribe(in string dagdaName);
  /* Unsubscribe. */
  void unsubscribe(in string dagdaName);

  /* To identify the data manager node. */
  string getID();
  string getHostname();

  /* To lock the access to a data. */
  void lockData(in string dataID);
  void unlockData(in string dataID);

  dataStatus getDataStatus(in string dataID);

  string getBestSource(in string destDagda, in string dataID)
    raises(DataNotFound);

  void checkpointState();

  void subscribeParent(in string parentID);
  void unsubscribeParent();
};

typedef Dagda::SeqDagda_t SeqDagda_t;
typedef sequence<string> SeqIOR;
#endif
